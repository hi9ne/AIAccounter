# 🏗️ Как работает AIAccounter - Визуальная схема

## 🎯 Общая картина работы приложения

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│                        👤 ПОЛЬЗОВАТЕЛЬ                              │
│                                                                     │
└──────────────┬────────────────────────────────┬─────────────────────┘
               │                                │
               │                                │
       ┌───────▼─────────┐              ┌──────▼──────────┐
       │                 │              │                 │
       │  💬 Telegram    │              │  📱 Mini App    │
       │     Bot         │              │     (PWA)       │
       │                 │              │                 │
       │  • Текст        │              │  • Dashboard    │
       │  • Голос        │              │  • Графики      │
       │  • Команды      │              │  • История      │
       │                 │              │  • Отчёты       │
       └────────┬────────┘              └─────────┬───────┘
                │                                 │
                │                                 │
       ┌────────▼─────────────────────────────────▼───────┐
       │                                                   │
       │           🔥 FastAPI Backend                      │
       │         (Railway - Production)                    │
       │                                                   │
       │  📍 https://aiaccounterbackend...railway.app      │
       │                                                   │
       │  Эндпоинты:                                       │
       │  • POST /auth/telegram     → JWT токен            │
       │  • GET  /analytics/stats   → Статистика           │
       │  • GET  /analytics/overview → Полный обзор        │
       │  • GET  /expenses          → Список расходов      │
       │  • POST /expenses          → Добавить расход      │
       │  • GET  /rates/latest      → Курсы валют          │
       │  • GET  /reports/period    → Отчёты               │
       │                                                   │
       └──────────────────────┬────────────────────────────┘
                              │
                              │
                   ┌──────────▼──────────┐
                   │                     │
                   │  🗄️ PostgreSQL      │
                   │    (Supabase)       │
                   │                     │
                   │  Таблицы:           │
                   │  • users            │
                   │  • expenses         │
                   │  • income           │
                   │  • budgets          │
                   │  • exchange_rates   │
                   │  • notifications    │
                   │  • *_embeddings     │
                   │                     │
                   └─────────────────────┘
```

---

## 🔄 Поток данных: От пользователя к базе

### 📱 Через Mini App:

```
1. Пользователь открывает Mini App
   │
   ▼
2. Frontend проверяет токен в localStorage
   │
   ├─── Токена нет
   │    │
   │    ▼
   │    POST /auth/telegram
   │    {telegram_chat_id: 123456}
   │    │
   │    ▼
   │    Backend создаёт/находит юзера
   │    │
   │    ▼
   │    Генерирует JWT токен
   │    │
   │    ▼
   │    Frontend сохраняет токен
   │
   └─── Токен есть
        │
        ▼
3. Frontend запрашивает данные
   GET /analytics/overview?period=week
   Header: Authorization: Bearer <token>
   │
   ▼
4. Backend проверяет токен
   JWT decode → user_id
   │
   ▼
5. Backend делает SQL запросы
   SELECT SUM(amount) FROM expenses WHERE user_id = ?
   SELECT SUM(amount) FROM income WHERE user_id = ?
   │
   ▼
6. Backend конвертирует в нужную валюту
   amount * exchange_rate
   │
   ▼
7. Backend возвращает JSON
   {
     total_income: 50000,
     total_expense: 30000,
     balance: 20000,
     transactions: [...]
   }
   │
   ▼
8. Frontend кэширует ответ (5 минут TTL)
   cache.set('overview_week', data, 300)
   │
   ▼
9. Frontend рендерит UI
   • Обновляет баланс
   • Рисует графики
   • Показывает список транзакций
```

---

### 🤖 Через Telegram Bot:

```
1. Пользователь пишет боту: "Потратил 500 сом на еду"
   │
   ▼
2. Telegram → n8n webhook
   │
   ▼
3. n8n: Message Type Switch
   │
   ├─── Голосовое → Whisper API → Текст
   │
   └─── Текстовое → Extract text
        │
        ▼
4. n8n: Main AI Agent (GPT-4o-mini)
   System prompt: "Ты финансовый помощник..."
   User message: "Потратил 500 сом на еду"
   │
   ▼
5. AI анализирует запрос
   Распознаёт:
   • Тип: расход
   • Сумма: 500
   • Валюта: KGS
   • Категория: Еда
   │
   ▼
6. AI вызывает tool: Create Expense
   {
     user_id: 123456,
     amount: 500,
     currency: "KGS",
     category: "Еда",
     date: "2025-11-21"
   }
   │
   ▼
7. n8n: PostgreSQL Insert
   INSERT INTO expenses (user_id, amount, category, ...)
   VALUES (...)
   │
   ▼
8. n8n: Generate Embedding (RAG)
   OpenAI text-embedding-3-small
   "500 сом на еду 21.11.2025"
   │
   ▼
9. n8n: Save Embedding
   INSERT INTO expenses_embeddings
   (expense_id, embedding, content, user_id)
   │
   ▼
10. AI формирует ответ
    "✅ Записал расход 500 сом на категорию Еда"
    │
    ▼
11. n8n → Telegram: Send Message
    Пользователь получает подтверждение
    │
    ▼
12. Mini App (если открыт) обновляется автоматически
    при следующем запросе (cache TTL)
```

---

## 🧠 Как работают AI агенты

```
┌────────────────────────────────────────────────────────┐
│                  Main AI Agent                         │
│              (Главный оркестратор)                      │
│                                                        │
│  Model: GPT-4o-mini                                    │
│  Memory: 10 последних сообщений                         │
│                                                        │
│  Функции:                                              │
│  1. Анализирует запрос пользователя                     │
│  2. Определяет тип операции                            │
│  3. Вызывает нужного агента или tool                    │
│  4. Формирует понятный ответ                           │
│                                                        │
└─────┬──────────────────────────────────────────────┬───┘
      │                                              │
      │                                              │
┌─────▼──────────┐                          ┌────────▼──────────┐
│                │                          │                   │
│ Income Agent   │                          │  Expenses Agent   │
│                │                          │                   │
│ Специалист по  │                          │  Специалист по    │
│ ДОХОДАМ        │                          │  РАСХОДАМ         │
│                │                          │                   │
│ Tools:         │                          │  Tools:           │
│ • Get Income   │                          │  • Get Expenses   │
│ • RAG Search   │                          │  • RAG Search     │
│ • Calculator   │                          │  • Calculator     │
│                │                          │                   │
└────────────────┘                          └───────────────────┘
```

### Пример работы:

```
Пользователь: "Сколько я потратил на транспорт в этом месяце?"

1. Main Agent получает вопрос
   │
   ▼
2. Анализирует: это вопрос о расходах
   │
   ▼
3. Вызывает Expenses Agent
   │
   ▼
4. Expenses Agent:
   a) Определяет категорию: "Транспорт"
   b) Определяет период: "этот месяц" (01-30 ноября)
   c) Делает SQL запрос:
      SELECT SUM(amount) FROM expenses
      WHERE user_id = ?
        AND category = 'Транспорт'
        AND date >= '2025-11-01'
        AND date <= '2025-11-30'
   d) Получает: 3500 сом
   │
   ▼
5. Expenses Agent возвращает результат Main Agent
   │
   ▼
6. Main Agent формирует ответ:
   "В ноябре вы потратили на транспорт 3,500 сом"
   │
   ▼
7. Отправка пользователю
```

---

## 💰 Как работает конвертация валют

```
1. Пользователь в настройках выбрал валюту: USD
   │
   ▼
2. В БД есть транзакции в разных валютах:
   • Расход 1000 KGS (еда)
   • Расход 50 USD (подписка)
   • Доход 500 EUR (фриланс)
   │
   ▼
3. Frontend запрашивает данные
   GET /analytics/stats?currency=USD
   │
   ▼
4. Backend загружает курсы из таблицы exchange_rates
   KGS → USD = 0.0115
   EUR → USD = 1.08
   USD → USD = 1.0
   │
   ▼
5. Backend конвертирует каждую транзакцию
   1000 KGS * 0.0115 = 11.5 USD
   50 USD * 1.0 = 50 USD
   500 EUR * 1.08 = 540 USD
   │
   ▼
6. Backend возвращает сумму в USD
   total_expense = 61.5 USD
   total_income = 540 USD
   balance = 478.5 USD
   │
   ▼
7. Frontend отображает в выбранной валюте
   💰 Balance: $478.50
```

---

## 📊 Как работает кэширование

```
┌──────────────────────────────────────────────────────┐
│                  Запрос данных                       │
└─────────────────────┬────────────────────────────────┘
                      │
                      ▼
            ┌─────────────────┐
            │ Проверить кэш?  │
            └────┬────────┬───┘
                 │ Да     │ Нет
                 │        │
        ┌────────▼────┐   │
        │ Есть в кэше?│   │
        └────┬───┬────┘   │
             │ Да│ Нет    │
             │   │        │
    ┌────────▼┐  │        │
    │Не истёк?│  │        │
    └────┬──┬─┘  │        │
         │Да│Нет │        │
         │  └────┴────────┘
         │       │
         │       ▼
         │  ┌─────────────────┐
         │  │ API запрос      │
         │  │ GET /analytics  │
         │  └────────┬────────┘
         │           │
         │           ▼
         │  ┌─────────────────┐
         │  │ Backend обработка│
         │  │ SQL queries     │
         │  └────────┬────────┘
         │           │
         │           ▼
         │  ┌─────────────────┐
         │  │ Сохранить в кэш │
         │  │ TTL: 5 минут    │
         │  └────────┬────────┘
         │           │
         └───────────┘
                     │
                     ▼
            ┌────────────────┐
            │ Вернуть данные │
            └────────────────┘
```

### Уровни кэширования:

```
1. Memory Cache (в RAM браузера)
   - Быстрый доступ
   - Сбрасывается при перезагрузке страницы
   - TTL: 5 минут

2. LocalStorage Cache (на диске)
   - Персистентный
   - Восстанавливается после перезагрузки
   - Версионирован (APP_VERSION)

3. Service Worker Cache (для offline)
   - Кэш статических файлов (HTML, CSS, JS)
   - Кэш API ответов (fallback)
   - Обновляется при новой версии

4. Backend кэш (будущее: Redis)
   - Пока не реализован
   - Планируется для rate limiting и hot data
```

---

## 🔐 Как работает авторизация

```
┌────────────────────────────────────────────────────────┐
│  1. Пользователь открывает Mini App в Telegram         │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  2. Telegram WebApp SDK передаёт initData             │
│     {                                                  │
│       user: {                                          │
│         id: 123456,                                    │
│         first_name: "User",                            │
│         username: "username"                           │
│       }                                                │
│     }                                                  │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  3. Frontend отправляет на backend                     │
│     POST /auth/telegram                                │
│     {                                                  │
│       telegram_chat_id: "123456",                      │
│       first_name: "User",                              │
│       username: "username"                             │
│     }                                                  │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  4. Backend проверяет в БД                             │
│     SELECT * FROM users                                │
│     WHERE telegram_chat_id = 123456                    │
│                                                        │
│     Если нет → CREATE новый user                       │
│     Если есть → UPDATE данные                          │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  5. Backend генерирует JWT токен                       │
│     {                                                  │
│       "sub": "user_id",    ← ID юзера в БД             │
│       "exp": 1732200000    ← Время истечения (30 мин)  │
│     }                                                  │
│     Подписывается SECRET_KEY                           │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  6. Frontend получает токен                            │
│     {                                                  │
│       "access_token": "eyJ0eXAi...",                   │
│       "token_type": "bearer",                          │
│       "expires_in": 1800                               │
│     }                                                  │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  7. Frontend сохраняет токен                           │
│     localStorage.setItem('auth_token', token)          │
│     api.setToken(token)                                │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  8. Все последующие запросы включают токен             │
│     GET /analytics/stats                               │
│     Headers: {                                         │
│       Authorization: "Bearer eyJ0eXAi..."              │
│     }                                                  │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  9. Backend валидирует токен на каждом запросе         │
│     • Декодирует JWT                                   │
│     • Проверяет подпись (SECRET_KEY)                   │
│     • Проверяет срок действия (exp)                    │
│     • Извлекает user_id из "sub"                       │
│     • Загружает User из БД                             │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  10. Backend выполняет запрос с user_id                │
│      SELECT * FROM expenses                            │
│      WHERE user_id = ?                                 │
└────────────────────────────────────────────────────────┘
```

---

## 📈 Как работают графики и аналитика

### Главная страница (Dashboard):

```
1. loadDashboard() вызывается
   │
   ▼
2. Определяется период (week по умолчанию)
   period = 'week'
   │
   ▼
3. Вычисляются даты
   const dates = getPeriodDates('week')
   // start: 2025-11-18 (понедельник)
   // end: 2025-11-24 (воскресенье)
   │
   ▼
4. API запрос с кэшированием
   const data = await api.getOverview({
     period: 'week',
     start_date: '2025-11-18',
     end_date: '2025-11-24'
   })
   │
   ▼
5. Backend SQL запросы (параллельно):
   a) SELECT SUM(amount) FROM income ...
   b) SELECT SUM(amount) FROM expenses ...
   c) SELECT category, SUM(amount) FROM expenses GROUP BY category ...
   d) SELECT date, amount FROM expenses ORDER BY date DESC LIMIT 10
   │
   ▼
6. Backend агрегирует результат
   {
     stats: {
       total_income: 50000,
       total_expense: 30000,
       balance: 20000
     },
     top_categories: [
       {category: "Еда", amount: 10000, percent: 33.3},
       {category: "Транспорт", amount: 5000, percent: 16.7}
     ],
     recent_transactions: [...]
   }
   │
   ▼
7. Frontend рендерит UI
   a) Обновляет баланс
      document.getElementById('main-balance').textContent = "20,000 с"
   
   b) Обновляет карточки доходов/расходов
      document.getElementById('total-income').textContent = "50,000 с"
      document.getElementById('total-expense').textContent = "30,000 с"
   
   c) Рендерит топ категории
      top_categories.forEach(cat => {
        HTML += `
          <div class="category-item">
            <span>${cat.category}</span>
            <span>${cat.amount} с (${cat.percent}%)</span>
          </div>
        `
      })
   
   d) Рендерит последние транзакции
      transactions.forEach(tx => {
        HTML += `
          <div class="transaction-item">
            <span>${tx.category}</span>
            <span>${tx.amount} с</span>
            <span>${tx.date}</span>
          </div>
        `
      })
```

### Страница аналитики:

```
1. loadAnalytics() вызывается
   │
   ▼
2. Параллельные запросы
   const [stats, categories, trends] = await Promise.all([
     api.getStats(params),
     api.getTopCategories(params),
     api.getTrends(params)
   ])
   │
   ▼
3. Рендер графиков
   
   a) Линейный график (Balance Trend)
      Chart.js line chart
      X: даты (последние 30 дней)
      Y: баланс (накопительно)
   
   b) Pie Chart (Категории)
      ApexCharts donut
      Labels: категории
      Values: суммы расходов
   
   c) Bar Chart (Тренды)
      Chart.js bar chart
      X: дни недели
      Y: сумма расходов
      Color: зелёный (доходы), красный (расходы)
```

---

## 🔄 Жизненный цикл транзакции

```
┌──────────────────────────────────────────────────────┐
│  СОЗДАНИЕ ТРАНЗАКЦИИ                                 │
└──────────────────┬───────────────────────────────────┘
                   │
     ┌─────────────┴──────────────┐
     │                            │
┌────▼─────────┐       ┌─────────▼────────┐
│ Через бота   │       │ Через API        │
│ (n8n)        │       │ (будущее)        │
└────┬─────────┘       └─────────┬────────┘
     │                           │
     └───────────┬───────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│  1. INSERT INTO expenses                               │
│     (user_id, amount, currency, category, date)        │
│     VALUES (?, ?, ?, ?, ?)                             │
│     RETURNING id                                       │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  2. Генерация embedding (RAG)                          │
│     content = f"{amount} {currency} {category} {date}" │
│     embedding = openai.embeddings.create(              │
│       model="text-embedding-3-small",                  │
│       input=content                                    │
│     )                                                  │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  3. INSERT INTO expenses_embeddings                    │
│     (expense_id, embedding, content, user_id)          │
│     VALUES (?, ?, ?, ?)                                │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  4. Проверка бюджета                                   │
│     IF total_expense_this_month > budget:              │
│       CREATE notification (budget_alert)               │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  ТРАНЗАКЦИЯ СОЗДАНА ✅                                 │
└────────────────────────────────────────────────────────┘
```

```
┌──────────────────────────────────────────────────────┐
│  УДАЛЕНИЕ ТРАНЗАКЦИИ (Soft Delete)                   │
└──────────────────┬───────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  DELETE /expenses/123                                  │
│  Authorization: Bearer <token>                         │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  Backend проверяет:                                    │
│  1. Токен валиден?                                     │
│  2. Expense принадлежит этому user?                    │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  UPDATE expenses                                       │
│  SET deleted_at = NOW()                                │
│  WHERE id = 123 AND user_id = ?                        │
└──────────────────┬─────────────────────────────────────┘
                   │
                   ▼
┌────────────────────────────────────────────────────────┐
│  Уведомление пользователю                              │
│  "✅ Транзакция удалена"                               │
└────────────────────────────────────────────────────────┘
```

---

## 🎨 Как работает переключение тем

```
1. Пользователь кликает кнопку темы
   │
   ▼
2. toggleTheme() вызывается
   │
   ▼
3. Определяется следующая тема
   auto → light → dark → auto
   │
   ▼
4. Сохраняется в localStorage
   localStorage.setItem('theme', 'dark')
   │
   ▼
5. Применяется data-attribute
   document.documentElement.setAttribute('data-theme', 'dark')
   │
   ▼
6. CSS variables автоматически меняются
   [data-theme="dark"] {
     --bg-primary: #111827;
     --text-primary: #F9FAFB;
     ...
   }
   │
   ▼
7. UI мгновенно перекрашивается
```

---

## 📱 Как работает PWA (Service Worker)

```
1. Пользователь первый раз открывает сайт
   │
   ▼
2. index.html регистрирует Service Worker
   navigator.serviceWorker.register('sw.js')
   │
   ▼
3. SW устанавливается (install event)
   • Кэширует критичные файлы:
     - index.html
     - app.js
     - style.css
     - api-helper.js
   │
   ▼
4. SW активируется (activate event)
   • Удаляет старые версии кэша
   • Занимает контроль над страницей
   │
   ▼
5. При последующих запросах (fetch event)
   
   Для статики (HTML/CSS/JS):
   ┌──────────────────┐
   │ Пробуем сеть     │
   └────┬─────────────┘
        │
        ├─── Успех → Обновляем кэш + возвращаем
        │
        └─── Ошибка → Берём из кэша (offline)
   
   Для API:
   ┌──────────────────┐
   │ Пробуем сеть     │
   └────┬─────────────┘
        │
        ├─── Успех → Кэшируем + возвращаем
        │
        └─── Ошибка → Берём из кэша (если есть)
```

---

## 🏁 ИТОГОВАЯ СХЕМА ВСЕХ ВЗАИМОДЕЙСТВИЙ

```
                    ┌──────────────┐
                    │  👤 USER     │
                    └──────┬───────┘
                           │
          ┌────────────────┼────────────────┐
          │                │                │
    ┌─────▼─────┐    ┌────▼────┐    ┌─────▼─────┐
    │ Telegram  │    │ Browser │    │ n8n cron  │
    │ Bot       │    │ Mini App│    │ jobs      │
    └─────┬─────┘    └────┬────┘    └─────┬─────┘
          │               │               │
          │               │               │
          └───────┬───────┴───────┬───────┘
                  │               │
          ┌───────▼───────┐   ┌───▼──────────┐
          │ n8n Workflows │   │ FastAPI      │
          │ (AI Agents)   │   │ Backend      │
          └───────┬───────┘   └───┬──────────┘
                  │               │
                  └───────┬───────┘
                          │
                   ┌──────▼────────┐
                   │ PostgreSQL DB │
                   │ (Supabase)    │
                   └───────────────┘
```

**Вот и всё! Теперь ты знаешь как работает каждая часть системы! 🚀**

---

**Последнее обновление:** 21 ноября 2025  
**Версия:** 1.0
